<!DOCTYPE html>
<html>
  <head>
    <title>sb3fix - fix corrupted Scratch projects</title>
    <meta charset="utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      :root {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      .error {
        font-family: monospace;
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <h1>sb3fix (early prototype)</h1>
    <p>Insert sb3 files into the input below, and sb3fix will fix common sources of corruption for you.</p>
    <p>
      <input class="file" type="file" accept=".sb3" multiple autocomplete="off">
    </p>

    <div class="output"></div>

    <h2>Code</h2>
    <p>Open source on GitHub: <a href="https://github.com/TurboWarp/sb3fix">https://github.com/TurboWarp/sb3fix</a></p>

    <h2>Privacy</h2>
    <p>Files are processed locally on your computer and never sent to any server.</p>

    <h2>Which errors does this fix?</h2>
    <ul>
      <li><code>{"validationError":"Could not parse as a valid SB2 or SB3 project.","sb3Errors":[{"keyword":"type","dataPath":".targets[1].costumes[0].name","schemaPath":"#/properties/name/type","params":{"type":"string"},"message":"should be string"}],"sb2Errors":[{"keyword":"required","dataPath":"","schemaPath":"#/required","params":{"missingProperty":"objName"},"message":"should have required property 'objName'"}]}</code></li>
      <li><code>{"validationError":"Could not parse as a valid SB2 or SB3 project.","sb3Errors":[{"keyword":"type","dataPath":".targets[1].sounds[0].name","schemaPath":"#/properties/name/type","params":{"type":"string"},"message":"should be string"}],"sb2Errors":[{"keyword":"required","dataPath":"","schemaPath":"#/required","params":{"missingProperty":"objName"},"message":"should have required property 'objName'"}]}</code></li>
    </ul>

    <script src="dependencies/jszip.min.js"></script>
    <script src="sb3fix.js"></script>
    <script>
      const input = document.querySelector('.file');
      const output = document.querySelector('.output');

      const stringifyError = (error) => {
        if (error && error.message && error.stack) {
          return `${error.message}\n${error.stack}`;
        }
        return `${error}`;
      };

      input.addEventListener('change', async (e) => {
        while (output.firstChild) {
          output.removeChild(output.firstChild);
        }

        for (const file of e.target.files) {
          const container = document.createElement('div');
          output.appendChild(container);

          container.appendChild(Object.assign(document.createElement('h3'), {
            textContent: `Processing ${file.name}`
          }));

          try {
            const fixed = await sb3fix(file);

            if (fixed.log.length > 0) {
              const listOfFixes = document.createElement('ul');
              for (const log of fixed.log) {
                listOfFixes.appendChild(Object.assign(document.createElement('li'), {
                  textContent: log
                }));
              }
              container.appendChild(listOfFixes);
            } else {
              container.appendChild(Object.assign(document.createElement('p'), {
                textContent: 'no fixes were found'
              }));
            }

            const blob = new Blob([fixed.newZip], {
              type: 'application/x.scratch.sb3'
            });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `fixed ${file.name}`;
            link.textContent = `Download fixed ${file.name}`;
            container.appendChild(link);
          } catch (err) {
            container.appendChild(Object.assign(document.createElement('p'), {
              className: 'error',
              textContent: `ERROR:\n${stringifyError(err)}`
            }));
          }
        }
      });
    </script>
  </body>
</html>
